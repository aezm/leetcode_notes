链表是一种通过指针串在一起的线性结构，每一个节点由两部分组成：数据域和指针域。
链表的入口节点称为头节点。
链表的类型：单链表，双链表，循环链表（解决约瑟夫环问题）
链表的存储形式：非连续分布

### 1. 构造链表
```python
class ListNode:
def __init__(self, val, next = None):
	self.val = val
	self.next = next
```

### 2. 移除链表元素
- 设置虚拟头节点：*返回时需要删除虚拟头节点*
- 直接使用原头节点：*注意删除头节点时的操作*
- 递归
```python
# 虚拟头节点法
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:     
        empty_head = ListNode(next = head)    
        point = empty_head

        while point.next:
            if point.next.val == val:
                point.next = point.next.next
            else:
                point = point.next
        return empty_head.next
```
*当使用python写 使用原节点法 时：当链表为空时，语句 while point.next != None 会报错。原因：self.head是指向第一个元素的，此时为None,所以没有next属性，自然就会报错。*
```python
# 使用原节点法
class Solution:
    def removeElements(self, head: Optional[ListNode], val: int) -> Optional[ListNode]:
        while head and head.val == val:
            head = head.next

        point = head
        while point and point.next:
            if point.next.val == val:
                point.next = point.next.next
            else:
                point = point.next

        return head
```

### 3. 设计链表
- 单链表
```python
class ListNode:
	# 节点初始化
    def __init__(self, val = 0, next = None):
        self.val = val
        self.next = next
        

class MyLinkedList:
	# 链表初始化
    def __init__(self):
        self.empty_head = ListNode()    # 虚拟头节点
        self.size = 0

	# 获取下标为index的节点的值，如不存在该节点则返回-1
    def get(self, index: int) -> int:
        if index >= self.size or index < 0:
            return -1

        point = self.empty_head
        for i in range(index):
            point = point.next

		return point.next.val    # 注意！！！

	# 在链表开头插入节点
    def addAtHead(self, val: int) -> None:
        self.empty_head.next = ListNode(val, self.empty_head.next)
        self.size += 1

	# 在链表结尾插入节点
    def addAtTail(self, val: int) -> None:
        point = self.empty_head
        while point.next:
            point = point.next
        point.next = ListNode(val)
        self.size += 1

	# 在下标为index的节点之前插入节点，如index与链表长度相等，则将该节点插入链表结尾
    def addAtIndex(self, index: int, val: int) -> None:
        if index > self.size or index < 0:
            return

        point = self.empty_head
        for i in range(index):
            point = point.next
        point.next = ListNode(val, point.next)
        self.size += 1

	# 删除下标为index的节点
    def deleteAtIndex(self, index: int) -> None:
        if index >= self.size or index < 0:
            return

        point = self.empty_head
        for i in range(index):
            point = point.next
        point.next = point.next.next
        self.size -= 1
```
- 双链表

### 4. 翻转链表
- 双指针
- 递归

### 5. 亮亮交换链表中的节点
- 虚拟头节点

### 6. 删除链表的倒数第N个节点
- 虚拟头节点
- 快慢指针：扫描一遍

### 7. 链表相交
- 哈希表
- 双指针：数学解法 a + (b + c) = b + (a + c)
```python
class Solution:
    def getIntersectionNode(self, headA: ListNode, headB: ListNode) -> ListNode:
        A = headA
        B = headB

        while A != B:
            A = A.next if A else headB
            B = B.next if B else headA
        return A
```

### 8. 环形链表II

