### 1. 翻转字符串里的单词
- 基本思路：（1）翻转整个字符串；（2）删除字符串中多余空格；（3）翻转每个单词
```
class Solution:
    def reverseWords(self, s: str) -> str:
        # 反转整个字符串
        s = s[::-1]
        # 将字符串拆分为单词，并反转每个单词
        # split()函数能够自动忽略多余的空白字符
        s = ' '.join(word[::-1] for word in s.split())
        return s
```

```
```
```
class Solution:
    def reverseSingleWord(self, s, start: int, end: int):
        while start < end:
            s[start], s[end] = s[end], s[start]
            end -= 1
            start += 1

    def reverseWords(self, s: str) -> str:
        # reverse string
        s = s[::-1]
  
        # remove extra space
        fast = 0
        result = ''
        while fast < len(s):
            if s[fast] != ' ':
                if len(result) != 0:
                    result += ' '
                while fast < len(s) and s[fast] != ' ':
                    result += s[fast]
                    fast += 1
            else:
                fast += 1

        # reverse words
        fast = 0
        slow = 0
        result = list(result)
        while fast <= len(result):
            if fast == len(result) or result[fast] == ' ':
                self.reverseSingleWord(result, slow, fast - 1)
                slow = fast + 1
                fast += 1
            else:
                fast += 1
        return ''.join(result)

if __name__ == '__main__':
    s = "the sky    is blue   "
    print(Solution().reverseWords(s))
```

### 2. 删除链表的倒数第N个节点
- 基本思路：双指针法；fast指针用于定位，slow指针用于删除；先让fast指针往前走n+1步，这样当fast指针指向链表末尾（即None）时，slow指针恰好指向要删除节点的前一个节点

### 3. 链表相交
- 算法原理： 由于两个链表在后面某节点相交，那么当A指针和B指针从后对齐时，往后同时移动必然会相交
- 基本思路：
	1. 指针A指向链表A， 指针B指向链表B；先获得两个链表的长度，而后将较长的链表的指针向前移动n步到与较短链表的剩余步数相等，最后将两个指针同时向后移动，当两个指针相等时则链表相交
	2. 等比例法 a + (b + c) = b + (a + c)；两个指针一个从链表A出发，一个从链表B出发，同时遍历两个链表，当指针指向相等时，则链表相交

### 4. 三数之和
- 基本思路：双指针+去重
	1. 判断数组长度是否大于3，如果否则直接返回null
	2. 对数组进行从小到大排序
	3. 从 `i = 0` 遍历排序后数组：
		- 如果 `nums[i] > 0`，则不可能有三数之和等于val，返回结果
		- 如果 `nums[i] == nums[i - 1]`，则去重
		- 左指针 `left = i + 1`，右指针 `right = len(nums) - 1`
			- 当 `nums[i] + nums[left] + nums[right] > 0`，说明`nums[right]`太大，right左移
			- 当 `nums[i] + nums[left] + nums[right] < 0`，说明`nums[left]`太小，left右移
			- 当 `nums[i] + nums[left] + nums[right] == 0`，执行循环，判断左界和右界是否和下一位置重复，去除重复解。并同时将 left、right指针移到下一位置，寻找新的解